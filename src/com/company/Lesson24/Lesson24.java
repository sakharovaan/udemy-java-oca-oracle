package com.company.Lesson24;

abstract public class Lesson24 {
    public static void main(String[] args) {
        //базовый класс ничего не знает о том что эти методы должны делать
        //но он знает что эти методы должны быть
    }

    abstract void foo(); //не должен иметь тела

    //нельзя создать объект абстрактного класса
}

class Test extends Lesson24 { // он тоже должен быть абстрактным или перезаписывать все методы родителя
    // если абстрактный класс наследуется от абстрактного, то наследует все переменные
    // абстрактные переменные быть не могут
    // абстрактный класс не может быть final
    //не могут быть методы final abstract, private abstract, static abstract

    @Override
    void foo() {

    }
    //конечный класс абстрактного класса - конкретный класс
}

class Test2 extends Lesson24 implements HelpAble, SwimAble { //должен перезаписать все методы интерфейса
    @Override
    void foo() {

    }

    @Override
    public void help() {

    }

    @Override
    public void swim(String s) {
        System.out.println(CONSTANT);
    }
}

interface HelpAble{ //может содержать только абстрактные методы
    void help(); //можем не писать слово abstract

    int CONSTANT = 5; //добавляется public final static в любом случае
}

interface SwimAble{ //может содержать только абстрактные методы
    void swim(String hello); //можем не писать слово abstract
} //интерфейс - это контракт, в котором указано, что класс сможет сделать, если он имплементирует интерфейс
//но он обязан снабдить все методы телами
//если класс имплементировал интерфейс, мы заранее можем угадать что он делает
//интерфейс позволяет работать с multiple inheritance, потому что класс может имплементировать методы с одним названием от них
//List <String> l = new ArrayList <>(); -- ArrayList имплементирует интерфейс List, можно ссылаться с переменной типа интерфейса (Class is an Interface)

//невозможно создать объект интерфейса, у него нет конструктора
//только один интерфейс может быть public
//интерфейс и его методы не может быть final


//сближаем разные классы, если они имплементируют один интерфейс -- с помощью того что создаём объекты этих классов с переменной типа интерфейса

//в разных интерфейсах одного класса могут быть одинаковые имена+разные аргументы, но должны быть одинаковые типы возврата

//интерфейс может наследовать любое количество интерфейсов

//Java 8
interface Hello {
    default void hi(){}; //default метод должен иметь тело. это дефолтное тело, чтобы не перезаписывать его везде
    //можем заоверрадить в наследнике и тогда заставим классы имплементировать его

    static void bye(){}; //не наследуется классами, собственный метод интерфейса, нужно вызывать как Hello.bye();
}//интерфейс можно импортировать


//Java 9
interface Wowsers {
    private static void hello() {
        //jelly(); non-static не может быть использован внутри статичных методов
    }; //
    private void jelly() {}; //нельзя сделать abstract, может быть только внутри интерфейса в static и non-static методах

    //если класс имплементирует интерфейсы с константами с одинаковыми именами, то нужно обращаться к имени интерфейса
}