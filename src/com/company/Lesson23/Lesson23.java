package com.company.Lesson23;

public class Lesson23 {
    public static void main(String[] args) {
        //можно вернуть null вместо любого типа объекта, вместо любого return type
        //можно возвращать конвертируемые значения (int-char)

        //Teacher t = new Teacher(); - reference переменная ссылается на объект того же типа
        //можно Parent p = new Child();
        //нельзя Child c = new Parent();
        //переменная суперкласса может ссылаться на любой объект сабкласса

        //но тип данных переменных будет определять то, к чему мы можем получить доступ -- мы сможем получить только к тому что унаследовано в суперклассе

        //можно написать return Object и возвращать любой объект. Даже int[] -- это ковариантные return type

        //overriding - перезапись, это не то же что overloading - перегрузка
        //перезапись если то же имя и набор параметров и тот же return type или сабкласс, access modifier такой же или менее строгий

        //нет понятия перезаписи переменных

        //binding - определение вызываемого метода, основываясь на объекте, который производит вызов или типе данных reference variable
        //бывает compile time (private/static/final methods - не могут быть перезаписаны!) и run time - в рантайме определяется на какой объект - компилятор не может определить
        //какой метод должен быть вызван
        //compile - early binding; runtime - late binding
        //все переменные имеют compile time binding
        //@Override - информирует компилятор о том что метод перезаписан, можно проверить оверрайдится ли

        //в рантайме бы определился метод правильно, а вот поле нет

        //даже если мы сделаем такой же static в потомке, то всё равно будет вызван родительский static
        //static - не overriding, а hiding - имя, список параметров, ковариантный return, такой же или легче access mod
        //variable hiding - объявление переменной с таким же именем, необязательно типом
        //hide - static/non-private variables
        //static не оверрайдятся потому что они не подразумевают создание объектов

        //private методы не могут быть hidden, потому что не наследуются

        //final методы не могут быть перезаписаны или скрыты

        //final класс не может иметь потомков - все методы которые вызываются из него делают compile time binding и работают быстрее

        //если мы делаем static метод - то он резолвится при компиляции, и если метод вызвать из класса, то будет тот который в классе (потомок->родитель->родитель)
        //если без static -- то из класса-потомка будет вызываться метод потомка (потомок->родитель->потомок)

        //если мы определяем переменную типа родителя, то overload тоже можем видеть только его

        //по умолчанию у констуктора default modifier, и его нельзя инициализировать из других пакетов

        Lesson23 l = new Foo();
        l.hello(); //foo
    }

    public void hello(){
        System.out.println("hello Lesson23");
    }
}

final class Foo extends Lesson23 {
    public void hello() {
        System.out.println("hello Foo");
        super.hello(); //необязательно на первом месте
    }
}