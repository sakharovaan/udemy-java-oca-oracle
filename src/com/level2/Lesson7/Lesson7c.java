package com.level2.Lesson7;

// извещение потоков потоком
// wait -- освобождает монитор и переводит вызывающий объект в состояние ожидания, пока другой поток не вызовет notify
// notify -- НЕ освобождает монитор и будит поток, у которого был wait()
// notifyAll -- НЕ освобождает монитор и будит все потоки с wait()

//producer-consumer
//1 - producer пушит 5 объектов и засыпает
//2 - consumer берёт 5 объектов и вызывает notify(), чтобы producer проснулся и добавил ещё
//3 - producer пушит ещё 5 объектов и будит consumer, а сам засыпает
//producer и consumer синхронизируются по одному объекту (нельзя одновременно запустить методы, которые кладут и берут)
//в таком виде производитель и потребитель могут работать одновременно, засыпает только производитель если стек полный

public class Lesson7c {
    Object lock = new Object();
    int truba = 0;

    public static void main(String[] args) {

    }
    // эти два метода синхронизируются по this, поэтому не могут выполняться одновременно
    // но мы не можем угадать какой следующий поток захватит этот монитор
    public synchronized void putB(){
        notify(); // по умолчанию это значит this.notify();
        lock.notify(); //мы можем вызывать notify/wait и на другом объекте, по которому синхронизируемся
    }

    public synchronized void getB() throws InterruptedException{
        while (truba == 0){ //поток может проснуться случайно, поэтому лучше не if использовать, а while -- не надеяться на то что он проснётся только по notify()
            wait(1000); //можем передавать время ожидания
        }
    }
}

//deadlock -- когда 2 или более потоков заблокированы навсегда, они ожидают снятия взаимной блокировки
//возникает когда потоки используют объекты не в одинаковом порядке